// Errors generated by Gorror; DO NOT EDIT.

package storage

import (
	"errors"
	"fmt"
)

type _errWrap struct{ cause error }

func (w *_errWrap) Unwrap() error { return w.cause }

func (e errSpec) IsIn(err error) bool {
	var ei interface {
		Is(errSpec) bool
		Unwrap() error
	}
	if errors.As(err, &ei) {
		if ei.Is(e) {
			return true
		}
		return e.IsIn(ei.Unwrap())
	}
	return false
}

type errReadStorage struct {
	_errWrap
	filename string
}

func newErrReadStorage(filename string, err error) *errReadStorage {
	return &errReadStorage{_errWrap{err}, filename}
}

func (e *errReadStorage) Error() string {
	return fmt.Sprintf("could not read storage from file %q: %v", e.filename, e.cause)
}

func (e *errReadStorage) Wrap(cause error) error {
	e.cause = cause
	return e
}

func (*errReadStorage) Is(e errSpec) bool { return e == errReadStorageSpec }

type errNotJSON struct {
	_errWrap
	filename string
}

func newErrNotJSON(filename string, err error) *errNotJSON {
	return &errNotJSON{_errWrap{err}, filename}
}

func (e *errNotJSON) Error() string {
	return fmt.Sprintf("failed to parse JSON from %q: %v", e.filename, e.cause)
}

func (e *errNotJSON) Wrap(cause error) error {
	e.cause = cause
	return e
}

func (*errNotJSON) Is(e errSpec) bool { return e == errNotJSONSpec }

type errSerialize struct {
	_errWrap
}

func newErrSerialize(err error) *errSerialize {
	return &errSerialize{_errWrap{err}}
}

func (e *errSerialize) Error() string {
	return fmt.Sprintf("failed to serialize as JSON: %v", e.cause)
}

func (e *errSerialize) Wrap(cause error) error {
	e.cause = cause
	return e
}

func (*errSerialize) Is(e errSpec) bool { return e == errSerializeSpec }

type errWrite struct {
	_errWrap
	filename string
}

func newErrWrite(filename string, err error) *errWrite {
	return &errWrite{_errWrap{err}, filename}
}

func (e *errWrite) Error() string {
	return fmt.Sprintf("failed to write to %q: %v", e.filename, e.cause)
}

func (e *errWrite) Wrap(cause error) error {
	e.cause = cause
	return e
}

func (*errWrite) Is(e errSpec) bool { return e == errWriteSpec }

type errDrop struct {
	_errWrap
	filename string
}

func newErrDrop(filename string, err error) *errDrop {
	return &errDrop{_errWrap{err}, filename}
}

func (e *errDrop) Error() string {
	return fmt.Sprintf("failed to delete %q: %v", e.filename, e.cause)
}

func (e *errDrop) Wrap(cause error) error {
	e.cause = cause
	return e
}

func (*errDrop) Is(e errSpec) bool { return e == errDropSpec }
